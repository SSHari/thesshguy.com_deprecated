---
id: mock-me-a-ui-test
name: Mocked UI Integration Testing
date: 01/05/2022
---

# Mock Me a UI Test

<TLDR>
  Automate API mocking in your jest tests by using msw to respond with examples
  from a swagger document.
</TLDR>

By this point, it's well accepted that testing the code you write is a necessity, so I won't bore you with the testing spiel. That said, effective testing can be challenging. Mostly because it's a bit of an art and it requires practice.

What do I test?

What should I mock?

Making this decision can be a bit of a pain. When it comes to UI testing though, it can be a good idea to mock your API requests. The API layer is a good separation point because the exact data which is returned usually shouldn't affect the behavior of your UI.

## API Mocking

If you're building a UI then you'll probably end up having to make an API request at some point based on some user interaction. You have a few options to test that interaction, one of which is to mock the fetch api and manually return a sample response in each of your tests based on the requested endpoint.

Easy...

...but a bit of a pain because as the number of tests grows you'll have to manage each of the mock payloads and repeatedly import them every where, which leads to cluttered tests.

If you're working on a small team with a few developers or endpoints then this may not be a big deal, but for a lot of people that's not the case.

There are many ways to handle API mocking in your tests, but I want to discuss an alternative strategy which uses jest, msw and swagger to auto mock APIs for your tests. If you're working on a bigger team, you might be able to benefit from such a pattern.

I'm going to walk you through setting up a minimal repo that has auto mocking enabled, so that you can worry less about mocks and more about testing your business logic.

If you'd prefer to just take a look at the repo, you can check out my [mocked ui integration testing repo](https://github.com/SSHari/demos/tree/master/testing/mocked-ui-integration-testing).

## Build Me a Repo

<Note>This setup uses npm, but if you prefer yarn that's cool too.</Note>

First things first. Make a new folder and initialize a new npm project:

```bash
# Pick whatever values you want
npm init
```

### Install Dependencies

The following dependencies will be used when setting up your tests, but for now just install them.

```bash
npm install --save-dev msw openapi-backend whatwg-fetch
```

- [msw](https://mswjs.io/): intercepts api requests and allows mocked responses without having to change your business logic
- [openapi-backend](https://www.npmjs.com/package/openapi-backend): a middleware tool to validate and mock OpenAPI definition files (e.g. Swagger Docs)
- [whatwg-fetch](https://www.npmjs.com/package/whatwg-fetch): polyfill for the fetch api so that we can call fetch in our jest tests

### Set up Swagger

Install the following package:

```bash
npm install --save-dev swagger-cli
```

This package can be used to validate and transform a swagger `.yaml` file into a `.json` file for consumption in your jest tests.

Next we need to build a minimal swagger `.yaml` file with a demo endpoint.

Typically this would be managed / built by (hopefully in collaboration with) the developers working on the API side. But for the sake of this post, we'll make a small example file. Create a `swagger.yaml` file with the following contents:

```yaml
openapi: 3.0.0
info:
  title: Demo API
  description: A demo api to use in tests
  version: 1.0.0
paths:
  /users:
    get:
      summary: Returns a list of users.
      operationId: GetUsers
      responses:
        '200':
          description: A JSON array of user names.
          content:
            application/json:
              schema:
                type: array
                items:
                  type: string
              example: ['Tim', 'Tam']
```

<Note>
  It's extremely important that each of these endpoints has a unique{' '}
  <TopicText>operationId</TopicText> because that's what we'll use during the
  auto mocking process.
</Note>

Once you have the swagger file, we can add a validation and build step to your `package.json` file:

```json
{
  "scripts": {
    "build": "swagger-cli validate swagger.yaml && swagger-cli bundle --outfile swagger.json swagger.yaml"
  }
}
```

Running the above script will give you a json file called `swagger.json` which we can import in our jest tests. Leave this file alone for now. We'll come back to it once we finish our setup for everything else.

### Set up Jest

Install the following packages:

```bash
npm install --save-dev @babel/core @babel/preset-env babel-jest jest
```

Why babel?

Internally jest uses babel to transpile (**yes babel uses the term compile instead, but you get the gist**) any code which it doesn't know how to handle into something it can work with. In this case, we're [using babel with jest](https://jestjs.io/docs/getting-started#using-babel) to be able to use the module import syntax.

```js
// jest will error out on this line without the babel magic
import fortyTwo from 'the-answer-to-life';
```

Ok, with that out of the way, once we have babel installed, we'll need to include a babel configuration file for jest to take advantage of the magic.

Make a `babel.config.js` file and paste in the following:

```js
module.exports = {
  presets: [['@babel/preset-env', { targets: { node: 'current' } }]],
};
```

Next we need to make a slight tweak to the jest configuration to make sure we're running tests in [jsdom](https://github.com/jsdom/jsdom#readme) which is a pure-JavaScript implementation of many browser and web features which lets us simulate a real browser in our tests. In this case, we need to simulate the [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) object.

```js
export default {
  // The default environment is 'node' which won't work in our case
  testEnvironment: 'jsdom',
};
```

### Build the Mocks

If you've kept with me this long, you likely have setup fatigue.

Don't worry.

We're onto the actual code portion of this pattern. For the sake of brevity, I'm going to keep everything in the same file, but feel free to break things out based on your preferences.

We're going to build this file together, but you can go here if you just want to see [the complete version of the mock setup](https://github.com/SSHari/demos/blob/master/testing/mocked-ui-integration-testing/src/index.spec.ts).

It's a TypeScript file, so it may have a little extra, but you should get the idea.

Ok.

Make a file that will include your tests and make sure to add `.spec.` or `.test.` to the name so that jest can find it (e.g. `mock-test.spec.js`).

The first thing we'll do is import everything that we need:

```js
// used to parse a swagger document and provide an API to query that document
import OpenAPIBackend from 'openapi-backend';
// used to set up the endpoints we want to mock via msw
import { rest } from 'msw';
// used to set up request interception via msw
import { setupServer } from 'msw/node';
// the file from the beginning which is passed to the OpenAPIBackend package
import definition from './swagger.json';
// Polyfill for fetch since Jest doesn't include it
import 'whatwg-fetch';
```

Next we'll set up the OpenAPIBackend and MSW integration:

```js
/**
 * Setup mocks via openapi-backend
 * View full set of options here: https://github.com/anttiviljami/openapi-backend/blob/master/DOCS.md#new-openapibackendopts
 */
// Used to simulate the base path for your real endpoints
const apiRoot = '/api';
const api = new OpenAPIBackend({ definition, apiRoot });

/**
 * MSW / OpenAPIBackend Integration
 */
api.register('notImplemented', (...[openAPICtx, _req, res, ctx]) => {
  // Since no requests are registered all endpoints in the
  // swagger docs will fall through to this function.
  const { status, mock } = openAPICtx.api.mockResponseForOperation(
    openAPICtx.operation.operationId ?? '',
  );

  return res(ctx.status(status), ctx.json(mock));
});

api.register('notFound', (...[_openAPICtx, _req, res, ctx]) =>
  // If a request is made that isn't in the swagger docs return a 404
  res(ctx.status(404)),
);

/**
 * MSW Mocks
 */
const mockResponse = (...[req, res, ctx]) => {
  const { method, url, headers: headersRaw, body } = req;
  const path = url.pathname;
  const headers = headersRaw.all();

  const requestConfig = { method, path, headers, body };
  return api.handleRequest(requestConfig, req, res, ctx);
};

const mocks = [rest.get(/api/, mockResponse), rest.post(/api/, mockResponse)];
```

OpenAPIBackend allows you to register responses for endpoints in your swagger document. Instead of manually setting that up, we can rely on the <TopicText>notImplemented</TopicText> event. This event will run anytime an existing endpoint is queried from the swagger document. The event takes a callback function which receives the OpenAPIBackend context and the msw request resolver arguments.

Ok. That's kind of a lot, so let's take a step back and talk about them in a bit more depth.

The OpenAPIBackend context is an object which contains the parsed swagger document and methods to interact with that document. In this case, we're leveraging the `mockResponseForOperation` method which will take an <TopicText>operationId</TopicText> (this is why I mentioned this was important at the beginning) and find any examples for the endpoint with the matching id.

The next set of arguments comes from what was passed to the msw request resolver. Basically, when msw intercepts a request which you've set up a mock for then a callback function is invoked with those arguments. With the help of those arguments, we can return an expected response for the api request (via OpenAPIBackend).

In this case, the two types of requests we're mocking with msw is any **GET** request (i.e. `rest.get`) and any **POST** request (i.e. `rest.post`) with an endpoint that matches the regex `/api/` which in our case should catch everything. The callback function `mockResponse` parses the request and then calls the OpenAPIBackend's `handleRequest` method which will fire the `notImplemented` event for any expected request.

So then...what about unexpected requests?

An unexpected request is any request which hasn't been defined in your swagger document which means there's no example for us to use. OpenAPIBackend provides us with another event in this case which we can use called <TopicText>notFound</TopicText>. This event will receive the same arguments as the <TopicText>notImplemented</TopicText> event. We'll just immediately respond with a <TopicText>404</TopicText> via msw since there's nothing for us to do. This way, you'll get a <TopicText>404</TopicText> in your tests which you can deal with accordingly.

Next, let's do some testing setup.

```js
/**
 * Jest Setup
 */

// Passes the mocks and request handlers to msw for setup
const server = setupServer(...mocks);

beforeAll(async () => {
  // Initialize OpenAPIBackend
  await api.init();

  // Start MSW
  server.listen();
});

// Reset MSW mocks between tests
afterEach(server.resetHandlers);

// Stop MSW
afterAll(server.close);

// Request wrapper to make tests more concise
async function request(url, method = 'GET') {
  const response = await window.fetch(url, {
    method,
    headers: { 'Content-Type': 'application/json' },
  });

  switch (response.status) {
    case 200:
      return await response.json();
    case 404:
      return { error: 'No matching endpoint' };
    default:
      throw new Error(`Unexpected response ${response}`);
  }
}
```

I won't bore you with the details, but basically we're just initializing OpenAPIBackend and msw so that they're ready when our tests run. We're also creating a small wrapper around the fetch api to format the responses of our requests (i.e. pass an error on a <TopicText>404</TopicText> or just return the response).

Finally!

Tests.

That was quite a bit of setup, but once you take a look at the tests, you should be able to see the payoff.

```js
test('should return a list of users based on the example in the swagger docs', async () => {
  // I make a request to the endpoint defined in the swagger document (including the apiRoot in the path)
  // The response we get back is the example defined
  const users = await request('/api/users');
  expect(users).toEqual(['Tim', 'Tam']);
});

test('should return a 404 if a request is made to an endpoint which is not in the swagger docs', async () => {
  // I make a request to an endpoint which is not defined in the swagger document (including the apiRoot in the path)
  // The response we get back is an error because our mock setup returned a `404`
  const error = await request('/api/some-other-endpoint');
  expect(error).toEqual({ error: 'No matching endpoint' });
});
```

That's pretty much it.

The tests themselves aren't really that useful because they're just checking the response from the swagger document, but if you pair this pattern with proper UI testing, you can test the business logic of your UI code without having to worry about managing mocks as part of your tests. Ideally the swagger documentation is maintained as a collaborative effort and is a reflection of the agreed upon contract between UI / API developers which improves the overall confidence of your tests.

## Other Use Cases

While we went through the process of setting everything up for our test suite, there's nothing stopping us from enabling this behavior in the browser while we're doing development. One of the primary use cases of msw is to leverage a service worker in the browser and intercept / mock requests in development. Since OpenAPIBackend is just JavaScript it also works in the browser.

If you want to try it out, all you need to do is the following:

```js
// Notice that we're pulling from the main msw package and not the node one
import { setupWorker } from 'msw';

// This should be familiar
const worker = setupWorker(...mocks);

const setupDevServer = () => {
  // Start msw
  worker.start();
  // Initialize OpenAPIBackend
  api.init();
};
```

At this point, you can just call the `setupDevServer` function when you spin up your dev environment. Just make sure to wrap the function call in a development mode environment check so that it's not included in your production code.

```js
// Something like this should work
if (process.env.NODE_ENV !== 'prod') {
  setupDevServer();
}
```
